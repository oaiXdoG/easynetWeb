# 多应用管理平台设计方案（设计文档）

> 本文档用于向开发团队说明平台整体**概念模型、权限与角色设计原则、项目切换与界面渲染逻辑**。  
> **仅包含设计与抽象，不涉及任何代码实现细节。**

---

## 一、设计目标

构建一套 **支持多应用（项目）** 的统一管理平台，满足以下目标：

- 平台仅一套登录体系与管理界面
- 一个账号可被分配到多个项目
- 账号在不同项目下可拥有不同的权限角色
- 根据当前项目与权限动态渲染界面
- 权限模型清晰、边界明确、可长期扩展

---

## 二、核心概念定义

### 1. 账号（User）
- 平台级唯一身份
- 登录只发生一次
- 不直接绑定任何权限

> 权限永远通过「项目 + 角色」生效

---

### 2. 项目 / 应用（Project / Application）
- 本设计中 **项目 = 应用**，两者等价
- 项目是：
  - 业务隔离的最小单元
  - 权限生效的边界
  - 数据隔离的边界

切换项目即意味着：
- 切换权限上下文
- 切换可访问的界面与能力

---

### 3. 项目上下文（Current Project Context）

- 系统在任意时刻 **只存在一个当前项目**
- 所有界面渲染、权限判断、业务操作，均基于该上下文

> 不允许同时存在多个项目上下文

---

## 三、人员与权限层级设计

### 1. 超级管理员（Super Administrator）

**作用域：平台级**

- 平台初始化时存在
- 默认拥有平台内所有权限
- 不依赖任何项目授权
- 职责：
  - 平台治理
  - 项目创建
  - 权限兜底

> 超级管理员不作为日常业务使用角色

---

### 2. 项目管理员（Project Administrator）

**作用域：单个项目内**

- 每个项目都必须至少存在一个项目管理员
- 权限特点：
  - 拥有该项目下的全部能力权限
  - 可管理项目内用户
  - 可将账号加入项目
  - 可为账号分配项目内角色

> 项目管理员是项目作用域内的最高权限者

---

### 3. 普通用户（Member）

- 权限完全来源于：
  - 当前项目
  - 所属角色
- 可被打标签 / 分组（用于管理与筛选）

> 标签与分组 **不参与权限判断**

---

## 四、角色与权限设计原则

### 1. 角色（Role）

- **角色仅在项目内生效**
- 不同项目之间：
  - 角色相互独立
  - 角色结构与权限集合可不同

> 本设计明确选择：**项目内完全独立角色体系**

---

### 2. 权限（Permission）

#### 核心定义

权限的本质是：

> **在当前项目下，账号是否被允许执行某一类行为**

权限不等同于：
- 页面
- 按钮
- API

而是：
- 行为能力（Capability）

---

### 3. 权限与 UI / API 的关系（重要）

权限并不直接控制界面或接口，而是控制：

> **行为是否被允许发生**

关系如下：

```
能力权限
   ↓
行为是否允许
 ↙           ↘
UI 表现      API 调用
```

---

## 五、权限在系统中的三种使用场景

### 1. 页面级（是否渲染界面）

**设计原则：**

- 页面本身不拥有权限
- 页面代表一组“可执行行为”

**判断规则：**

> 若用户在当前项目下，至少拥有该页面所关联的一个能力权限，则该页面可被渲染

> 页面渲染属于 **体验层优化**，不是安全边界

---

### 2. 操作级（是否可操作按钮）

**设计原则：**

- 每个按钮 / 操作，对应一个明确的行为
- 行为是否允许，由能力权限决定

**表现方式：**
- 有权限 → 显示 / 可点击
- 无权限 → 隐藏或禁用

---

### 3. 能力级（是否允许 API 行为）

**设计原则（不可妥协）：**

> API 是权限的唯一最终裁决点

- 不信任任何前端判断
- 不依赖页面是否可见
- 不依赖按钮是否禁用

只要能力权限不满足，行为必须被拒绝。

---

## 六、项目切换与权限生效逻辑

### 1. 登录成功后

- 返回账号可访问的项目列表
- 设置一个默认项目

此时：
- 尚未进入任何具体业务
- 权限未完全展开

---

### 2. 切换项目

切换项目会触发：

- 当前项目上下文变更
- 当前项目下：
  - 用户角色确定
  - 权限集合确定
  - 菜单结构确定

> 所有界面与行为，必须基于切换后的项目上下文重新判断

---

## 七、菜单、角色与项目的绑定原则

### 1. 项目级菜单基线
- 每个项目拥有独立的菜单基线集合（Project Menu），仅分配给项目的菜单才可能被展示。
- 菜单数据需持久化：建议表结构 `project_menu`（或菜单树）与 `project_menu_rel` 记录项目 ↔ 菜单关系。
- 前端渲染菜单只依赖后端返回的“当前项目可见菜单树”，不再硬编码固定菜单。

### 2. 角色菜单子集
- 角色是权限载体；角色的菜单集合必须是该项目菜单基线的子集。
- 建议角色菜单关系表 `role_menu`，写入时校验菜单是否属于该项目。
- 删除项目菜单时，应级联清理相关角色映射，防止脏数据。

### 3. 权限与菜单的层次
- 菜单控制“可见与导航”；按钮/接口由能力权限控制，可选 `role_permission`、`project_permission`。
- 角色权限与角色菜单相互独立但都受项目基线约束：`role_menu ⊆ project_menu`，`role_permission ⊆ project_permission`。

### 4. 切换项目的前端加载流程
- 切换项目后调用后端一次性返回：`{ roles, menus, permissions, projectId }`。
- 动态路由：根据返回的菜单/权限添加或过滤路由（保留 login/403/404 等静态路由）。
- Pinia 中缓存当前项目的 `menus` 与 `permissions`；切换项目时清空再重新加载。

### 5. 推荐接口最小集
- `GET /project/:id/context` → 返回当前账号在该项目下的 `menus`、`permissions`、`roles`。
- `GET/PUT /project/:id/roles/:roleId/menus` → 维护角色菜单（需校验属于项目基线）。
- `GET /project/:id/menus` → 项目菜单基线（管理端使用）。

---

## 八、关于界面与 API 独立性的说明

本设计基于以下前提：

- 每个页面为独立 Vue 模块
- 每个 API 为独立能力入口

在此前提下：

- 权限模型不依赖页面结构
- UI 可自由调整
- API 始终作为安全底线

---

## 九、设计约束与边界声明

为保证系统长期可维护性，需遵守以下约束：

1. 权限语义在同一项目内必须保持一致
2. 权限不直接等同于 UI 元素
3. 标签 / 分组不参与权限判断
4. 不存在跨项目权限继承
5. 所有行为必须在项目上下文内进行

---

## 十、总结

本方案通过：

- 平台级账号
- 项目级角色
- 能力级权限

构建出一个：

- 逻辑清晰
- 权限边界明确
- 支持多项目
- 可长期演进

的多应用管理平台设计模型。

> **权限只回答一个问题：在某个项目下，这个账号能不能做这件事。**

---

（完）
