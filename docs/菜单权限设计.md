# 菜单权限设计文档

## 设计理念

**前端为主 + 后端只存权限关系**

- 前端：完全控制菜单定义（名称、图标、路径）
- 后端：只存储 menuCode 与项目/角色的关系
- 不存在同步问题，菜单变更只需修改前端代码

---

## 权限层级

```
平台全量菜单（前端代码定义）
    ⊇
项目可用菜单（超管创建项目时配置）
    ⊇
角色可用菜单（项目管理员创建角色时配置）
    ⊇
用户可见菜单（用户所有角色菜单的并集）
```

---

## 数据结构

### 前端菜单配置（src/config/menus.ts）

```typescript
// 平台全量菜单
export const platformMenus: PlatformMenuGroup[] = [
  {
    groupCode: 'console',      // 分组唯一标识
    groupTitle: '控制台',       // 分组标题
    sortOrder: 1,
    children: [
      {
        menuCode: 'dashboard', // 菜单唯一标识（用于与后端匹配）
        menuName: '数据看板',   // 菜单名称
        icon: 'dashboard',     // Material Icons 图标
        path: '/dashboard',    // 路由路径
        sortOrder: 1
      }
    ]
  }
]

// 超管专属菜单
export const superAdminMenus: PlatformMenuGroup[] = [...]
```

### 后端存储（只存 menuCode）

```sql
-- 项目菜单关系表
CREATE TABLE sys_project_menu (
  project_id INT,
  menu_code VARCHAR(50)  -- 只存 menuCode
);

-- 角色菜单关系表
CREATE TABLE sys_role_menu (
  role_id INT,
  menu_code VARCHAR(50)  -- 只存 menuCode
);
```

### 后端返回数据

```typescript
// 项目上下文
interface CurrentProjectContext {
  id: number
  projectCode: string
  projectName: string
  roles: RoleItem[]
  permissions: string[]
  visibleMenuCodes: string[]  // 用户可见的菜单 code 列表（推荐仅存叶子 menuCode；可选包含 groupCode 以兼容旧数据）
}
```

---

## 数据流

```
1. 超管创建项目
   └── 选择项目可用菜单 → 存入 sys_project_menu

2. 项目管理员创建角色
   └── 选择角色可用菜单（只能选项目菜单的子集）→ 存入 sys_role_menu

3. 用户登录
   └── 后端计算用户可见菜单（角色菜单并集）→ 返回 visibleMenuCodes

4. 前端渲染
   └── menuStore 根据 visibleMenuCodes 过滤 platformMenus → AppSidebar 渲染
```

---

## 核心代码

### menuStore（src/stores/menu/index.ts）

```typescript
// 根据 menuCode 过滤菜单
const filteredMenus = computed(() => {
  // 超级管理员：显示所有菜单
  if (authStore.isSuperAdmin) {
    return [...platformMenus, ...superAdminMenus]
  }

  // 普通用户：根据 visibleMenuCodes 过滤
  return filterMenusByCode(visibleMenuCodes.value, false)
})
```

### filterMenusByCode（src/config/menus.ts）

```typescript
export function filterMenusByCode(
  visibleCodes: string[],
  includeSuperAdmin: boolean = false
): PlatformMenuGroup[] {
  const codeSet = new Set(visibleCodes)

  return platformMenus
    .map(group => ({
      ...group,
      children: group.children.filter(item => codeSet.has(item.menuCode))
    }))
    .filter(group => group.children.length > 0)
}
```

---

## 添加新菜单

### 步骤

1. **修改前端配置**（src/config/menus.ts）
   ```typescript
   {
     groupCode: 'new_group',
     groupTitle: '新功能',
     children: [
       { menuCode: 'new_feature', menuName: '新功能', icon: 'star', path: '/new' }
     ]
   }
   ```

2. **添加路由**（src/router/index.ts）
   ```typescript
   { path: 'new', name: 'NewFeature', component: () => import('@/views/New/Index.vue') }
   ```

3. **创建页面组件**（src/views/New/Index.vue）

4. **后端配置**（可选）
   - 如果是新项目：创建项目时勾选新菜单
   - 如果是已有项目：更新项目菜单配置

### 无需修改

- 后端代码（只存 menuCode，不关心菜单详情）
- AppSidebar 组件（自动从 menuStore 读取）

---

## Mock 数据示例

```typescript
// 项目可用菜单（超管配置）
export const mockEcommerceProjectMenuCodes = [
  // 推荐：只存叶子 menuCode（分组由前端根据子菜单推导）
  'dashboard',
  'log_app',  // 注意：没有 log_server，该项目不开放此功能
  'project_member', 'project_role', 'project_permission'
]

// 角色可用菜单（项目管理员配置）
export const mockEcommerceOperatorMenuCodes = [
  'dashboard',
  'log_app'
  // 运营人员没有项目设置权限
]
```

---

## 优点

1. **无同步问题** - 菜单定义在前端代码中，不需要与后端同步
2. **后端轻量** - 只存 menuCode，不存储冗余信息
3. **层级约束清晰** - 项目 → 角色 → 用户，逐级收窄
4. **灵活性高** - 不同项目可以有不同的功能模块
5. **易于维护** - 菜单变更只需改前端代码
