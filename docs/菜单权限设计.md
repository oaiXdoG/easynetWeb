# 菜单权限设计文档

## 设计理念

**前端为主 + 后端同步平台菜单 + 只存权限关系**

- 前端：完全控制菜单定义（名称、图标、路径）- src/config/menus.ts
- 后端：存储平台菜单模板（project_id = 0）和权限关系（menuCode）
- 超管可通过"同步菜单"API将前端配置同步到后端数据库
- 项目/角色只存储 menuCode 关联，不存储菜单详细信息

---

## 用户类型和访问规则

### 超级管理员（is_super_admin = 1）

**特点：**
- ✅ 只在平台层管理，不进入任何项目
- ✅ 管理项目生命周期（增删改查、启用/禁用）
- ✅ 配置项目的侧边栏权限（项目可以使用哪些菜单）
- ✅ 管理 API 权限
- ✅ 管理账号生命周期（增删改查、启用/禁用）
- ✅ 分配账号到项目、移除账号
- ❌ 不属于任何项目（sys_user_project 表中无记录）

**登录后体验：**
```
登录 → 直接进入平台管理界面
         ├─ 系统管理
         │   ├─ 账号管理 (system_user)
         │   └─ 项目管理 (system_project)
         └─ （无项目切换功能）
```

**如需体验项目：**
- 超管自己创建普通账号
- 自己分配权限、分配项目

---

### 普通用户（is_super_admin = 0）

**有项目时：**
```
登录 → 选择项目（或默认项目）→ 进入项目工作台
                                  ├─ 控制台 (dashboard)
                                  ├─ 日志 (log_app, log_server)
                                  └─ 项目设置 (member, role, permission)
```

- ✅ 可以属于多个项目
- ✅ 在每个项目下角色不同（角色是项目级的）
- ✅ 根据项目内角色看到不同菜单
- ❌ 看不到"系统管理"菜单

**无项目时：**
```
登录 → 空布局 + 提示"还未加入项目"
       （无任何操作按钮）
```

- ❌ 无法进行任何操作
- ❌ 只显示空布局

---

## 权限层级

```
平台全量菜单（前端代码定义 + 同步到数据库 project_id=0）
    ⊇
项目可用菜单（超管创建项目时配置）
    ⊇
角色可用菜单（项目管理员创建角色时配置，角色是项目级的）
    ⊇
用户可见菜单（用户在当前项目的所有角色菜单的并集）
```

---

## 菜单同步机制

### 平台菜单初始化和同步

由于前端 `config/menus.ts` 是菜单配置的唯一来源，后端数据库需要存储平台菜单数据供超管创建项目时选择。

**新的表结构设计**：
- `sys_menu_group`：存储菜单分组（console、log、project_settings、system）
- `sys_menu`：存储具体菜单项（dashboard、log_app、project_member...）
- `sys_project_menu`：项目-菜单关系表（只存 menu_id）
- `sys_role_menu`：角色-菜单关系表（只存 menu_id）

详见：`docs/数据库设计.md`

#### 同步流程

```
超管界面 → 点击"同步菜单"按钮
             ↓
    读取 config/menus.ts 中的 platformMenus + superAdminMenus
             ↓
    POST /api/admin/sync-menus
    {
      groups: [{ groupCode, groupTitle, sortOrder }],
      menus: [{ groupCode, menuCode, menuName, icon, path, component, sortOrder }]
    }
             ↓
    后端对比数据库 sys_menu_group 和 sys_menu
             ↓
    执行增删改操作（事务）
             ↓
    返回同步结果
```

#### API 设计

**接口**：`POST /api/admin/sync-menus`

**权限**：仅超级管理员可调用

**请求参数**：
```typescript
interface SyncMenusRequest {
  groups: Array<{
    groupCode: string
    groupTitle: string
    sortOrder: number
  }>
  menus: Array<{
    groupCode: string      // 所属分组编码
    menuCode: string
    menuName: string
    icon: string
    path: string
    component: string
    sortOrder: number
  }>
}
```

**响应**：
```typescript
interface SyncMenusResponse {
  success: boolean
  message: string
  data: {
    groups: {
      added: number
      updated: number
      deleted: number
    }
    menus: {
      added: number
      updated: number
      deleted: number
    }
    total: {
      groups: number
      menus: number
    }
  }
}
```

#### 后端同步逻辑

1. **验证权限**：确保调用者是超级管理员
2. **同步分组**：
   - 读取数据库 `sys_menu_group` 表
   - 对比差异：新增/更新/删除
3. **同步菜单**：
   - 读取数据库 `sys_menu` 表
   - 通过 `groupCode` 找到对应的 `group_id`
   - 对比差异：新增/更新/删除
4. **删除检查**：
   - 删除分组前，检查是否有菜单属于该分组
   - 删除菜单前，检查 `sys_project_menu` 和 `sys_role_menu` 是否有引用
5. **事务执行**：所有变更在一个事务中完成
6. **返回结果**：统计变更数量

#### 前端实现

**位置**：`src/views/System/Project.vue`（项目管理页面）

**UI**：在页面顶部添加"同步菜单"按钮

**实现**：
```typescript
import { getAllMenus, formatMenusForSync } from '@/config/menus'

async function syncMenus() {
  const allMenus = getAllMenus() // platformMenus + superAdminMenus
  const formatted = formatMenusForSync(allMenus)

  const result = await syncMenusApi(formatted)

  // 显示同步结果
  showMessage(`同步完成：
    分组 - 新增 ${result.data.groups.added}，更新 ${result.data.groups.updated}，删除 ${result.data.groups.deleted}
    菜单 - 新增 ${result.data.menus.added}，更新 ${result.data.menus.updated}，删除 ${result.data.menus.deleted}
  `)
}
```

---

## 数据结构

### 前端菜单配置（src/config/menus.ts）

```typescript
// 平台全量菜单
export const platformMenus: PlatformMenuGroup[] = [
  {
    groupCode: 'console',      // 分组唯一标识
    groupTitle: '控制台',       // 分组标题
    sortOrder: 1,
    children: [
      {
        menuCode: 'dashboard', // 菜单唯一标识（用于与后端匹配）
        menuName: '数据看板',   // 菜单名称
        icon: 'dashboard',     // Material Icons 图标
        path: '/dashboard',    // 路由路径
        sortOrder: 1
      }
    ]
  }
]

// 超管专属菜单
export const superAdminMenus: PlatformMenuGroup[] = [...]
```

### 后端存储（双表结构）

```sql
-- 菜单分组表（不包含 project_id）
CREATE TABLE sys_menu_group (
  id BIGINT UNSIGNED PRIMARY KEY,
  group_code VARCHAR(50) UNIQUE,  -- 分组编码
  group_title VARCHAR(100),       -- 分组标题
  sort_order INT                  -- 排序
);

-- 菜单表（不包含 project_id）
CREATE TABLE sys_menu (
  id BIGINT UNSIGNED PRIMARY KEY,
  group_id BIGINT UNSIGNED,       -- 所属分组ID（外键）
  menu_code VARCHAR(50) UNIQUE,   -- 菜单编码
  menu_name VARCHAR(100),         -- 菜单名称
  icon VARCHAR(100),              -- 图标
  path VARCHAR(255),              -- 路由路径
  component VARCHAR(255),         -- 组件路径
  sort_order INT                  -- 排序
);

-- 项目-菜单关系表
CREATE TABLE sys_project_menu (
  project_id BIGINT UNSIGNED,
  menu_id BIGINT UNSIGNED,        -- 只存 menu_id，不存 group_id
  UNIQUE (project_id, menu_id)
);

-- 角色-菜单关系表
CREATE TABLE sys_role_menu (
  role_id BIGINT UNSIGNED,
  menu_id BIGINT UNSIGNED,        -- 只存 menu_id，不存 group_id
  UNIQUE (role_id, menu_id)
);
```

### 后端返回数据

```typescript
// 项目上下文
interface CurrentProjectContext {
  id: number
  projectCode: string
  projectName: string
  roles: RoleItem[]
  permissions: string[]
  visibleMenuCodes: string[]  // 用户可见的菜单 code 列表（推荐仅存叶子 menuCode；可选包含 groupCode 以兼容旧数据）
}
```

---

## 数据流

```
1. 超管创建项目
   └── 选择项目可用菜单 → 存入 sys_project_menu

2. 项目管理员创建角色
   └── 选择角色可用菜单（只能选项目菜单的子集）→ 存入 sys_role_menu

3. 用户登录
   └── 后端计算用户可见菜单（角色菜单并集）→ 返回 visibleMenuCodes

4. 前端渲染
   └── menuStore 根据 visibleMenuCodes 过滤 platformMenus → AppSidebar 渲染
```

---

## 核心代码

### menuStore（src/stores/menu/index.ts）

```typescript
// 根据 menuCode 过滤菜单
const filteredMenus = computed(() => {
  // 超级管理员：显示所有菜单
  if (authStore.isSuperAdmin) {
    return [...platformMenus, ...superAdminMenus]
  }

  // 普通用户：根据 visibleMenuCodes 过滤
  return filterMenusByCode(visibleMenuCodes.value, false)
})
```

### filterMenusByCode（src/config/menus.ts）

```typescript
export function filterMenusByCode(
  visibleCodes: string[],
  includeSuperAdmin: boolean = false
): PlatformMenuGroup[] {
  const codeSet = new Set(visibleCodes)

  return platformMenus
    .map(group => ({
      ...group,
      children: group.children.filter(item => codeSet.has(item.menuCode))
    }))
    .filter(group => group.children.length > 0)
}
```

---

## 添加新菜单

### 步骤

1. **修改前端配置**（src/config/menus.ts）
   ```typescript
   {
     groupCode: 'new_group',
     groupTitle: '新功能',
     children: [
       { menuCode: 'new_feature', menuName: '新功能', icon: 'star', path: '/new' }
     ]
   }
   ```

2. **添加路由**（src/router/index.ts）
   ```typescript
   { path: 'new', name: 'NewFeature', component: () => import('@/views/New/Index.vue') }
   ```

3. **创建页面组件**（src/views/New/Index.vue）

4. **后端配置**（可选）
   - 如果是新项目：创建项目时勾选新菜单
   - 如果是已有项目：更新项目菜单配置

### 无需修改

- 后端代码（只存 menuCode，不关心菜单详情）
- AppSidebar 组件（自动从 menuStore 读取）

---

## Mock 数据示例

```typescript
// 项目可用菜单（超管配置）
export const mockEcommerceProjectMenuCodes = [
  // 推荐：只存叶子 menuCode（分组由前端根据子菜单推导）
  'dashboard',
  'log_app',  // 注意：没有 log_server，该项目不开放此功能
  'project_member', 'project_role', 'project_permission'
]

// 角色可用菜单（项目管理员配置）
export const mockEcommerceOperatorMenuCodes = [
  'dashboard',
  'log_app'
  // 运营人员没有项目设置权限
]
```

---

## 优点

1. **无同步问题** - 菜单定义在前端代码中，不需要与后端同步
2. **后端轻量** - 只存 menuCode，不存储冗余信息
3. **层级约束清晰** - 项目 → 角色 → 用户，逐级收窄
4. **灵活性高** - 不同项目可以有不同的功能模块
5. **易于维护** - 菜单变更只需改前端代码
