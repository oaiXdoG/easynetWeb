# 数据库设计方案对比文档

## 一、我的设计方案（旧方案）

### 核心表结构

#### 1. 用户相关
```sql
-- 用户表
sys_user (
  id,
  username,
  password,
  is_super_admin
)

-- 用户-项目关系表（只记录归属关系）
sys_user_project (
  id,
  user_id,
  project_id,
  is_default
)

-- 用户-项目-角色关系表（三元关系表）
sys_user_project_role (
  id,
  user_id,
  project_id,
  role_id
)
```

#### 2. 角色相关
```sql
-- 角色表
sys_role (
  id,
  project_id,
  role_code,      -- ⚠️ 多余的字段
  role_name,
  is_project_admin
)

-- 角色-菜单关系表（直接关联菜单）
sys_role_menu (
  id,
  role_id,
  menu_id
)

-- 角色-权限关系表
sys_role_permission (
  id,
  role_id,
  permission_id
)
```

#### 3. 菜单相关
```sql
-- 菜单分组表
sys_menu_group (
  id,
  group_code,
  group_title,
  sort_order
)

-- 菜单表
sys_menu (
  id,
  group_id,
  menu_code,
  menu_name,
  icon,
  path,
  component,
  sort_order
)

-- 项目-菜单关系表
sys_project_menu (
  id,
  project_id,
  menu_id
)

-- ⚠️ 没有角色-菜单分组关系表
```

#### 4. 权限相关
```sql
-- 权限表（与菜单混淆）
sys_permission (
  id,
  project_id,
  permission_code,
  permission_name,
  permission_type
)

-- 菜单-权限关系表（⚠️ 概念混乱）
sys_menu_permission (
  id,
  menu_id,
  permission_id
)
```

### 关系结构图

```
sys_user
    ↓
sys_user_project (只记录归属)
    ↓
sys_user_project_role (三元关系表)
    ↓
sys_role (有 role_code)
    ├→ sys_role_menu (直接分配菜单，无分组控制)
    └→ sys_role_permission

sys_project
    ↓
sys_project_menu

sys_menu_group
    ↓
sys_menu
```

### 设计问题

| 序号 | 问题 | 说明 |
|------|------|------|
| 1 | **三元关系表** | sys_user_project_role 设计复杂，查询麻烦 |
| 2 | **role_code 多余** | 既然用 role.id 做映射，role_code 没有实际作用 |
| 3 | **缺少分组权限控制** | 没有 sys_role_menu_group，无法实现"必须先分配分组才能分配菜单" |
| 4 | **menu 和 permission 混淆** | 菜单是界面，权限是操作，不应该混在一起 |
| 5 | **sys_menu_permission 表** | 这个表的存在意义不明确 |

---

## 二、用户的设计方案（新方案）

### 核心表结构

#### 1. 用户相关
```sql
-- 用户表
sys_user (
  id,
  username,
  password,
  is_super_admin
)

-- 用户-项目关系表（直接包含角色）
sys_user_project (
  id,
  user_id,
  project_id,
  role_id          -- ✅ 直接在归属表中指定角色
)
```

#### 2. 角色相关
```sql
-- 角色表（去掉 role_code）
sys_role (
  id,
  project_id,      -- 角色归属于项目
  role_name
)

-- 角色-菜单分组关系表（✅ 必须先分配）
sys_role_menu_group (
  id,
  role_id,
  menu_group_id
)

-- 角色-菜单关系表
sys_role_menu (
  id,
  role_id,
  menu_id
)
-- 业务规则：menu 必须属于已分配的 menu_group
```

#### 3. 菜单相关
```sql
-- 菜单分组表
sys_menu_group (
  id,
  group_code,
  group_title,
  sort_order
)

-- 菜单表
sys_menu (
  id,
  group_id,
  menu_code,
  menu_name,
  icon,
  path,
  component,
  sort_order
)

-- 项目-菜单关系表（只存 menu_id）
sys_project_menu (
  id,
  project_id,
  menu_id          -- ✅ 通过 sys_menu.group_id 推导分组
)
```

#### 4. 权限相关
```sql
-- ✅ 暂不涉及，专注于菜单权限
-- 如需操作权限，可后续扩展 sys_permission 和 sys_role_permission
```

### 关系结构图

```
sys_user
    ↓
sys_user_project (包含 role_id)
    ├→ sys_project
    └→ sys_role (项目级角色)
            ├→ sys_role_menu_group (必须先分配分组)
            └→ sys_role_menu (然后才能分配菜单)
                    ↓
                sys_menu
                    ↓
                sys_menu_group

sys_project
    ↓
sys_project_menu (只存 menu_id，推导 group)
```

### 设计优势

| 序号 | 优势 | 说明 |
|------|------|------|
| 1 | **去掉三元关系表** | 用户-项目-角色关系简化为 sys_user_project.role_id |
| 2 | **去掉 role_code** | 业务标识符无实际作用，直接用 id |
| 3 | **分层权限控制** | 必须先分配 menu_group，才能分配 menu |
| 4 | **职责清晰** | 菜单权限和操作权限分离 |
| 5 | **查询简单** | 关系链路短，查询效率高 |

---

## 三、详细对比

### 对比1：用户-角色关系

| 项目 | 我的设计 | 用户的设计 | 优劣 |
|------|---------|-----------|------|
| **表结构** | sys_user_project + sys_user_project_role | sys_user_project (含 role_id) | ✅ 用户的更简洁 |
| **关系复杂度** | 三元关系表 | 二元关系 | ✅ 用户的更简单 |
| **查询效率** | 需要 JOIN 两张表 | 只需查一张表 | ✅ 用户的更高效 |
| **数据冗余** | 低 | 稍高（一个用户在同一项目只能有一个角色） | ⚠️ 看业务需求 |

**用户在一个项目中是否可以有多个角色？**
- 我的设计：可以（sys_user_project_role 可以插入多条）
- 用户的设计：不可以（sys_user_project.role_id 只能存一个）

**哪个更合理？**
- 如果业务上一个用户在一个项目只有一个角色 → 用户的设计更合理
- 如果需要多角色 → 需要修改为独立的 sys_user_role 表

---

### 对比2：菜单权限控制

| 项目 | 我的设计 | 用户的设计 | 优劣 |
|------|---------|-----------|------|
| **分组权限** | ❌ 没有 | ✅ sys_role_menu_group | ✅ 用户的有分层控制 |
| **菜单权限** | sys_role_menu | sys_role_menu | 相同 |
| **业务规则** | 直接分配菜单 | 必须先分配分组，才能分配菜单 | ✅ 用户的更严谨 |
| **权限粒度** | 只有菜单级 | 分组级 + 菜单级 | ✅ 用户的更灵活 |

**用户的设计优势**：
- 可以整组授权（一次性给角色分配整个"日志"分组）
- 防止权限遗漏（必须先有分组才能有菜单）
- 更符合业务逻辑（先决定能看哪些模块，再细化到具体菜单）

---

### 对比3：角色标识

| 项目 | 我的设计 | 用户的设计 | 优劣 |
|------|---------|-----------|------|
| **role_code** | ✅ 有 | ❌ 没有 | ✅ 用户的更合理 |
| **唯一标识** | id + role_code | id | ✅ 用户的更简洁 |

**为什么 role_code 多余？**
- 既然所有关系都通过 role.id 映射
- role_code 不参与权限判断
- 作为业务标识符意义不大（role_name 已经够用）
- 增加了字段维护成本（要保证唯一性）

---

### 对比4：项目菜单存储

| 项目 | 我的设计 | 用户的设计 | 优劣 |
|------|---------|-----------|------|
| **存储内容** | menu_id | menu_id | 相同 |
| **分组推导** | ✅ 通过 sys_menu.group_id | ✅ 通过 sys_menu.group_id | 相同 |

**两者都采用只存 menu_id 的方案**，分组信息通过关联查询获得，避免冗余。

---

### 对比5：权限（Permission）概念

| 项目 | 我的设计 | 用户的设计 | 优劣 |
|------|---------|-----------|------|
| **sys_permission** | ✅ 有 | ❌ 暂无 | 看业务需求 |
| **sys_menu_permission** | ✅ 有 | ❌ 无 | ⚠️ 我的概念混乱 |
| **职责分离** | 菜单和权限混在一起 | 只关注菜单权限 | ✅ 用户的更清晰 |

**菜单 vs 权限的区别**：
- **菜单（Menu）**：界面导航，控制"用户能看到哪些页面"
  - 例如：dashboard、log_app、project_member

- **权限（Permission）**：操作能力，控制"用户能做什么操作"
  - 例如：user:create、user:delete、order:export

**我的设计问题**：
- sys_menu_permission 表试图建立菜单和权限的关系，但这是错误的
- 菜单和权限应该独立管理，都通过角色授予

**正确的设计应该是**：
```
sys_role
    ├→ sys_role_menu (控制能看到哪些页面)
    └→ sys_role_permission (控制能做哪些操作)
```

---

## 四、综合评价

### 优劣势对比表

| 维度 | 我的设计 | 用户的设计 | 胜者 |
|------|---------|-----------|------|
| **简洁性** | 三元关系表，复杂 | 二元关系，简单 | ✅ 用户 |
| **查询效率** | 需要多次 JOIN | 关系链路短 | ✅ 用户 |
| **权限粒度** | 只有菜单级 | 分组级 + 菜单级 | ✅ 用户 |
| **职责清晰** | 菜单和权限混淆 | 只关注菜单权限 | ✅ 用户 |
| **可维护性** | role_code 多余 | 字段精简 | ✅ 用户 |
| **扩展性** | 已包含 permission | 可后续扩展 | ⚖️ 平手 |
| **多角色支持** | ✅ 支持 | ❌ 不支持 | ⚠️ 看需求 |

---

## 五、结论

### 用户的设计明显更优，原因：

1. **✅ 关系更简单**
   - 去掉三元关系表 sys_user_project_role
   - 用户-项目-角色关系一张表搞定

2. **✅ 权限控制更严谨**
   - 新增 sys_role_menu_group 表
   - 强制"先分配分组，再分配菜单"的业务规则

3. **✅ 去掉多余字段**
   - 去掉 role_code
   - 既然用 id 做映射，code 完全没必要

4. **✅ 职责更清晰**
   - 专注于菜单权限
   - 不混淆 menu 和 permission 的概念

5. **✅ 查询更高效**
   - 关系链路短
   - 减少不必要的 JOIN

---

## 六、唯一需要确认的问题

### ⚠️ 一个用户在一个项目中是否可以有多个角色？

**场景示例**：
- 张三在项目A中既是"开发"角色，又是"测试"角色

**我的设计**：支持（sys_user_project_role 可以插入多条）
```sql
INSERT INTO sys_user_project_role VALUES (1, 1, 1); -- 张三-项目A-开发
INSERT INTO sys_user_project_role VALUES (2, 1, 2); -- 张三-项目A-测试
```

**用户的设计**：不支持（sys_user_project.role_id 只能存一个）
```sql
sys_user_project (
  user_id = 1,
  project_id = 1,
  role_id = 1  -- 只能存一个角色
)
```

### 解决方案

如果业务需要支持多角色，可以调整为：

```sql
-- 方案A：恢复独立的用户-角色关系表
sys_user_role (
  id,
  user_id,
  role_id
)

-- 方案B：允许 sys_user_project 有多条记录（去掉 UNIQUE 约束）
-- 但这样会导致项目归属信息冗余
```

**建议**：
- 如果大部分场景下一个用户在一个项目只有一个角色 → 使用用户的设计
- 如果确实需要多角色 → 使用方案A

---

## 七、最终推荐

**采用用户的设计方案**，原因如下：

1. **简洁性** - 关系更简单，易于理解和维护
2. **严谨性** - 分层权限控制更符合业务逻辑
3. **高效性** - 查询性能更好
4. **清晰性** - 职责分离明确

**需要调整的地方**：
1. ✅ 去掉所有 role_code 字段
2. ✅ 新增 sys_role_menu_group 表
3. ✅ 合并 sys_user_project 和角色关系
4. ⚠️ 确认是否需要支持多角色（如需要，额外增加 sys_user_role 表）

---

## 八、完整的表结构（用户方案）

```sql
-- 1. 用户表
CREATE TABLE sys_user (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  is_super_admin TINYINT NOT NULL DEFAULT 0
);

-- 2. 项目表
CREATE TABLE sys_project (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  project_name VARCHAR(100) NOT NULL
);

-- 3. 角色表（项目级，去掉 role_code）
CREATE TABLE sys_role (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  project_id BIGINT UNSIGNED NOT NULL,
  role_name VARCHAR(50) NOT NULL
);

-- 4. 用户-项目关系表（包含角色）
CREATE TABLE sys_user_project (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT UNSIGNED NOT NULL,
  project_id BIGINT UNSIGNED NOT NULL,
  role_id BIGINT UNSIGNED NOT NULL,
  UNIQUE KEY uk_user_project (user_id, project_id)
);

-- 5. 菜单分组表
CREATE TABLE sys_menu_group (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  group_code VARCHAR(50) NOT NULL UNIQUE,
  group_title VARCHAR(100) NOT NULL,
  sort_order INT NOT NULL DEFAULT 0
);

-- 6. 菜单表
CREATE TABLE sys_menu (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  group_id BIGINT UNSIGNED NOT NULL,
  menu_code VARCHAR(50) NOT NULL UNIQUE,
  menu_name VARCHAR(100) NOT NULL,
  icon VARCHAR(100),
  path VARCHAR(255),
  component VARCHAR(255),
  sort_order INT NOT NULL DEFAULT 0
);

-- 7. 项目-菜单关系表
CREATE TABLE sys_project_menu (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  project_id BIGINT UNSIGNED NOT NULL,
  menu_id BIGINT UNSIGNED NOT NULL,
  UNIQUE KEY uk_project_menu (project_id, menu_id)
);

-- 8. 角色-菜单分组关系表（新增）
CREATE TABLE sys_role_menu_group (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  role_id BIGINT UNSIGNED NOT NULL,
  menu_group_id BIGINT UNSIGNED NOT NULL,
  UNIQUE KEY uk_role_menu_group (role_id, menu_group_id)
);

-- 9. 角色-菜单关系表
CREATE TABLE sys_role_menu (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  role_id BIGINT UNSIGNED NOT NULL,
  menu_id BIGINT UNSIGNED NOT NULL,
  UNIQUE KEY uk_role_menu (role_id, menu_id)
);
-- 业务规则：menu 必须属于已分配的 menu_group
```

---

**文档生成时间**：2025-12-24
